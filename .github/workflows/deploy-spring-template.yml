name: Spring(JAVA) Deployment Template

on:
  workflow_call:
    inputs:
      SERVICE_NAME:
        required: true
        type: string
      BASE_REMOTE_PATH:
        required: true
        type: string
      PROFILE: # New input for the selected profile (dev/stage/prod)
        required: true
        type: string
    secrets:
      PREFIX_HOST:
        required: true
      PREFIX_PORT:
        required: true
      PREFIX_USER:
        required: true
      DOCKERHUB_USERNAME:
        required: true
      DOCKERHUB_TOKEN:
        required: true
      BASE64_KEY:
        required: true
      APP_DEV_YML: # New secret for dev config
        required: true
      APP_STAGE_YML: # New secret for stage config
        required: true
      APP_PROD_YML: # New secret for prod config
        required: true
      SLACK_WEBHOOK_URL:
        required: true

jobs:
  build_and_push_dockerhub:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Gradle 최적화 빌드 (jar 생성)
      - name: Cache Gradle
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: gradle-cache-${{ runner.os }}-${{ hashFiles('build.gradle*', 'settings.gradle*', 'gradle/libs.versions.toml') }}
          restore-keys: |
            gradle-cache-

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21

      - name: Create profile-specific application.yml files
        run: |
          mkdir -p ./src/main/resources
          echo "${{ secrets.APP_DEV_YML }}" > ./src/main/resources/application-dev.yml
          echo "${{ secrets.APP_STAGE_YML }}" > ./src/main/resources/application-stage.yml
          echo "${{ secrets.APP_PROD_YML }}" > ./src/main/resources/application-prod.yml

      - name: Build jar (bootJar + config cache)
        run: |
          chmod +x ./gradlew
          ./gradlew clean bootJar --parallel --daemon --configuration-cache
        env:
          CI: true

      # Docker Build & Push & Cleanup
      - name: DockerHub login
        run: |
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login \
            -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

      - name: Build image
        run: |
          IMAGE="jaepil9/${{ inputs.SERVICE_NAME }}:latest"
          echo "[BUILD] $IMAGE"
          docker build -t "$IMAGE" .

      - name: Push image
        run: |
          IMAGE="jaepil9/${{ inputs.SERVICE_NAME }}:latest"
          echo "[PUSH] $IMAGE"
          docker push "$IMAGE"

      - name: Cleanup old Docker Hub tags (keep only latest)
        run: |
          TAGS=$(curl -s "https://hub.docker.com/v2/repositories/jaepil9/${{ inputs.SERVICE_NAME }}/tags?page_size=100" \
            | jq -r '.results[].name')

          for TAG in $TAGS; do
            if [ "$TAG" != "latest" ]; then
              echo "Deleting tag: $TAG"
              TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d '{"username": "${{ secrets.DOCKERHUB_USERNAME }}", "password": "${{ secrets.DOCKERHUB_TOKEN }}"}' https://hub.docker.com/v2/users/login/ | jq -r .token)
              curl -s -X DELETE \
                -H "Authorization: JWT ${TOKEN}" \
                "https://hub.docker.com/v2/repositories/jaepil9/${{ inputs.SERVICE_NAME }}/tags/$TAG/"
            fi
          done

  deploy_to_server:
    runs-on: ubuntu-latest
    needs: build_and_push_dockerhub
    steps:
      # SSH Login & Deploy
      - name: Prepare SSH key
        run: |
          echo "${{ secrets.BASE64_KEY }}" | base64 --decode > private_key
          chmod 600 private_key

      - name: Show SSH key fingerprint
        run: |
          ssh-keygen -lf private_key

      - name: Deploy to server
        run: |
          ssh -o StrictHostKeyChecking=no -i private_key -p "${{ steps.port.outputs.port }}" \
            "${{ steps.user.outputs.user }}@${{ steps.host.outputs.host }}" '
            set -e
            cd ${{ inputs.BASE_REMOTE_PATH }}
          
            echo "[DEPLOY] docker compose pull ${{ inputs.SERVICE_NAME }}"
            docker compose pull ${{ inputs.SERVICE_NAME }}

            echo "[DEPLOY] docker compose up -d ${{ inputs.SERVICE_NAME }}"
            SPRING_PROFILE=${{ inputs.PROFILE }} docker compose up -d ${{ inputs.SERVICE_NAME }}

            echo "[CLEANUP] remove unused images"
            docker image prune -af || true
            '

  notify_slack:
    runs-on: ubuntu-latest
    needs: [deploy_to_server]
    if: always() # Job always runs, logic inside determines if a notification is sent
    steps:
      - name: Checkout .github repo to get user map
        uses: actions/checkout@v4
        with:
          repository: SYSTRAN-KOREA-AI/.github
          path: ".github-meta"

      - name: Read notification policy from map
        id: policy
        run: |
          USER_MAP_FILE=".github-meta/user-map.json"
          SERVICE_NAME="${{ inputs.SERVICE_NAME }}"

          # 1. Check if notifications are enabled for this service. Default to false if not specified.
          IS_ENABLED=$(jq -r ".projects[\"$SERVICE_NAME\"].notify // \"false\"" $USER_MAP_FILE)
          echo "is_enabled=$IS_ENABLED" >> "$GITHUB_OUTPUT"

          # 2. Find project owner's GitHub username from the service name
          OWNER_USERNAME=$(jq -r ".projects[\"$SERVICE_NAME\"].owner // \"null\"" $USER_MAP_FILE)

          # 3. Determine which GitHub username to use (owner, or actor if no owner)
          if [ "$OWNER_USERNAME" != "null" ]; then
            TARGET_USERNAME=$OWNER_USERNAME
          else
            TARGET_USERNAME="${{ github.actor }}"
          fi
          echo "target_user=$TARGET_USERNAME" >> "$GITHUB_OUTPUT"

      - name: Get Slack User ID for target
        id: slack-user
        if: steps.policy.outputs.is_enabled == 'true'
        run: |
          USER_MAP_FILE=".github-meta/user-map.json"
          TARGET_USERNAME="${{ steps.policy.outputs.target_user }}"

          # Get the Slack ID for the target username (fallback to 'channel')
          SLACK_USER_ID=$(jq -r ".users[\"$TARGET_USERNAME\"] // \"channel\"" $USER_MAP_FILE)

          echo "SLACK_MENTION=<@$SLACK_USER_ID>" >> "$GITHUB_OUTPUT"

      - name: Send Slack Notification
        if: steps.policy.outputs.is_enabled == 'true'
        uses: act10ns/slack@v2
        with:
          status: ${{ needs.deploy_to_server.result }}
          message: |
            ${{ steps.slack-user.outputs.SLACK_MENTION }} *${{ inputs.SERVICE_NAME }}* 서비스의 *${{ inputs.PROFILE }}* 환경 배포가 종료되었습니다.
            • *결과:* `${{ needs.deploy_to_server.result }}`
            • *실행자:* `${{ github.actor }}`
            • <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|워크플로우 실행 로그 보기>
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
